//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5 ../Grammars/OslcSearchTerms.g 2013-06-26 12:30:34

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace  OSLC4Net.Core.Query.Impl 
{
/******************************************************************************
 * Copyright (c) 2013 IBM Corporation.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v. 1.0 which accompanies this distribution. 
 *
 * The Eclipse Public License is available at http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at 
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors: 
 *
 *    Steve Pitchke - initial API and implementation
 *******************************************************************************/
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5")]
[System.CLSCompliant(false)]
public partial class OslcSearchTermsParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "COMMA", "ECHAR", "EOL", "STRING_LIST", "STRING_LITERAL", "WS"
	};
	public const int EOF=-1;
	public const int COMMA=4;
	public const int ECHAR=5;
	public const int EOL=6;
	public const int STRING_LIST=7;
	public const int STRING_LITERAL=8;
	public const int WS=9;

	public OslcSearchTermsParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public OslcSearchTermsParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return OslcSearchTermsParser.tokenNames; } }
	public override string GrammarFileName { get { return "../Grammars/OslcSearchTerms.g"; } }


	    public OslcSearchTermsParser(string searcTerms) :
			this(new CommonTokenStream(new OslcSearchTermsLexer(new ANTLRStringStream(searcTerms))))
	    {
	    }
		
		public object Result
		{
			get { return oslc_search_terms().Tree; }
		}       


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_oslc_search_terms();
	partial void LeaveRule_oslc_search_terms();
	// $ANTLR start "oslc_search_terms"
	// ../Grammars/OslcSearchTerms.g:41:1: oslc_search_terms : string_esc ( ',' string_esc )* -> ^( 'string_list' string_esc ( string_esc )* ) ;
	[GrammarRule("oslc_search_terms")]
	private AstParserRuleReturnScope<object, IToken> oslc_search_terms()
	{
		EnterRule_oslc_search_terms();
		EnterRule("oslc_search_terms", 1);
		TraceIn("oslc_search_terms", 1);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal2 = default(IToken);
		AstParserRuleReturnScope<object, IToken> string_esc1 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> string_esc3 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal2_tree = default(object);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_string_esc=new RewriteRuleSubtreeStream(adaptor,"rule string_esc");
		try { DebugEnterRule(GrammarFileName, "oslc_search_terms");
		DebugLocation(41, 1);
		try
		{
			// ../Grammars/OslcSearchTerms.g:41:22: ( string_esc ( ',' string_esc )* -> ^( 'string_list' string_esc ( string_esc )* ) )
			DebugEnterAlt(1);
			// ../Grammars/OslcSearchTerms.g:41:24: string_esc ( ',' string_esc )*
			{
			DebugLocation(41, 24);
			PushFollow(Follow._string_esc_in_oslc_search_terms60);
			string_esc1=string_esc();
			PopFollow();

			stream_string_esc.Add(string_esc1.Tree);
			DebugLocation(41, 35);
			// ../Grammars/OslcSearchTerms.g:41:35: ( ',' string_esc )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_1 = input.LA(1);

				if ((LA1_1==COMMA))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// ../Grammars/OslcSearchTerms.g:41:37: ',' string_esc
					{
					DebugLocation(41, 37);
					char_literal2=(IToken)Match(input,COMMA,Follow._COMMA_in_oslc_search_terms64);  
					stream_COMMA.Add(char_literal2);

					DebugLocation(41, 41);
					PushFollow(Follow._string_esc_in_oslc_search_terms66);
					string_esc3=string_esc();
					PopFollow();

					stream_string_esc.Add(string_esc3.Tree);

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }



			{
			// AST REWRITE
			// elements: string_esc, STRING_LIST, string_esc
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 41:55: -> ^( 'string_list' string_esc ( string_esc )* )
			{
				DebugLocation(41, 58);
				// ../Grammars/OslcSearchTerms.g:41:58: ^( 'string_list' string_esc ( string_esc )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(41, 60);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(STRING_LIST, "STRING_LIST"), root_1);

				DebugLocation(41, 74);
				adaptor.AddChild(root_1, stream_string_esc.NextTree());
				DebugLocation(41, 85);
				// ../Grammars/OslcSearchTerms.g:41:85: ( string_esc )*
				while ( stream_string_esc.HasNext )
				{
					DebugLocation(41, 86);
					adaptor.AddChild(root_1, stream_string_esc.NextTree());

				}
				stream_string_esc.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("oslc_search_terms", 1);
			LeaveRule("oslc_search_terms", 1);
			LeaveRule_oslc_search_terms();
		}
		DebugLocation(42, 1);
		} finally { DebugExitRule(GrammarFileName, "oslc_search_terms"); }
		return retval;

	}
	// $ANTLR end "oslc_search_terms"

	partial void EnterRule_string_esc();
	partial void LeaveRule_string_esc();
	// $ANTLR start "string_esc"
	// ../Grammars/OslcSearchTerms.g:44:1: string_esc : STRING_LITERAL ;
	[GrammarRule("string_esc")]
	private AstParserRuleReturnScope<object, IToken> string_esc()
	{
		EnterRule_string_esc();
		EnterRule("string_esc", 2);
		TraceIn("string_esc", 2);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken STRING_LITERAL4 = default(IToken);

		object STRING_LITERAL4_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "string_esc");
		DebugLocation(44, 31);
		try
		{
			// ../Grammars/OslcSearchTerms.g:44:15: ( STRING_LITERAL )
			DebugEnterAlt(1);
			// ../Grammars/OslcSearchTerms.g:44:17: STRING_LITERAL
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(44, 17);
			STRING_LITERAL4=(IToken)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_string_esc97); 
			STRING_LITERAL4_tree = (object)adaptor.Create(STRING_LITERAL4);
			adaptor.AddChild(root_0, STRING_LITERAL4_tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("string_esc", 2);
			LeaveRule("string_esc", 2);
			LeaveRule_string_esc();
		}
		DebugLocation(44, 31);
		} finally { DebugExitRule(GrammarFileName, "string_esc"); }
		return retval;

	}
	// $ANTLR end "string_esc"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _string_esc_in_oslc_search_terms60 = new BitSet(new ulong[]{0x12UL});
		public static readonly BitSet _COMMA_in_oslc_search_terms64 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _string_esc_in_oslc_search_terms66 = new BitSet(new ulong[]{0x12UL});
		public static readonly BitSet _STRING_LITERAL_in_string_esc97 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace  OSLC4Net.Core.Query.Impl 
