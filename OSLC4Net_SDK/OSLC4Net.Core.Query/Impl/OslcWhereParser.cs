//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5 ../Grammars/OslcWhere.g 2013-06-26 18:03:02

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace  OSLC4Net.Core.Query.Impl 
{
/******************************************************************************
 * Copyright (c) 2013 IBM Corporation.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v. 1.0 which accompanies this distribution. 
 *
 * The Eclipse Public License is available at http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at 
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors: 
 *
 *    Steve Pitchke - initial API and implementation
 *******************************************************************************/
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5")]
[System.CLSCompliant(false)]
public partial class OslcWhereParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ALPHA_CHARS", "AND", "ASTERISK", "BOOLEAN", "CLOSE_BRACE", "CLOSE_CURLY_BRACE", "CLOSE_SQUARE_BRACE", "COMMA", "COMPOUND_TERM", "DECIMAL", "DIGIT", "DOT", "ECHAR", "EOL", "EQUAL", "GREATER", "GREATER_EQUAL", "IN_TERM", "IN_VALUES", "IRI_REF", "LANGED_VALUE", "LANGTAG", "LESS", "LESS_EQUAL", "MINUS", "NOT", "NOT_EQUAL", "OPEN_BRACE", "OPEN_CURLY_BRACE", "OPEN_SQUARE_BRACE", "OR", "PLUS", "PNAME_LN", "PNAME_NS", "PN_CHARS", "PN_CHARS_BASE", "PN_CHARS_U", "PN_LOCAL", "PN_PREFIX", "REFERENCE", "SEMICOLON", "SIMPLE_TERM", "STRING_LITERAL", "TERMS", "TYPED_VALUE", "WS", "' '", "' and '", "' in'"
	};
	public const int EOF=-1;
	public const int T__50=50;
	public const int T__51=51;
	public const int T__52=52;
	public const int ALPHA_CHARS=4;
	public const int AND=5;
	public const int ASTERISK=6;
	public const int BOOLEAN=7;
	public const int CLOSE_BRACE=8;
	public const int CLOSE_CURLY_BRACE=9;
	public const int CLOSE_SQUARE_BRACE=10;
	public const int COMMA=11;
	public const int COMPOUND_TERM=12;
	public const int DECIMAL=13;
	public const int DIGIT=14;
	public const int DOT=15;
	public const int ECHAR=16;
	public const int EOL=17;
	public const int EQUAL=18;
	public const int GREATER=19;
	public const int GREATER_EQUAL=20;
	public const int IN_TERM=21;
	public const int IN_VALUES=22;
	public const int IRI_REF=23;
	public const int LANGED_VALUE=24;
	public const int LANGTAG=25;
	public const int LESS=26;
	public const int LESS_EQUAL=27;
	public const int MINUS=28;
	public const int NOT=29;
	public const int NOT_EQUAL=30;
	public const int OPEN_BRACE=31;
	public const int OPEN_CURLY_BRACE=32;
	public const int OPEN_SQUARE_BRACE=33;
	public const int OR=34;
	public const int PLUS=35;
	public const int PNAME_LN=36;
	public const int PNAME_NS=37;
	public const int PN_CHARS=38;
	public const int PN_CHARS_BASE=39;
	public const int PN_CHARS_U=40;
	public const int PN_LOCAL=41;
	public const int PN_PREFIX=42;
	public const int REFERENCE=43;
	public const int SEMICOLON=44;
	public const int SIMPLE_TERM=45;
	public const int STRING_LITERAL=46;
	public const int TERMS=47;
	public const int TYPED_VALUE=48;
	public const int WS=49;

	public OslcWhereParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public OslcWhereParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return OslcWhereParser.tokenNames; } }
	public override string GrammarFileName { get { return "../Grammars/OslcWhere.g"; } }


	    public OslcWhereParser(string where) :
			this(new CommonTokenStream(new OslcWhereLexer(new ANTLRStringStream(where))))
	    {
	    }
		
		public object Result
		{
			get { return oslc_where().Tree; }
		}


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_oslc_where();
	partial void LeaveRule_oslc_where();
	// $ANTLR start "oslc_where"
	// ../Grammars/OslcWhere.g:47:1: oslc_where : compound_term ;
	[GrammarRule("oslc_where")]
	private AstParserRuleReturnScope<object, IToken> oslc_where()
	{
		EnterRule_oslc_where();
		EnterRule("oslc_where", 1);
		TraceIn("oslc_where", 1);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> compound_term1 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "oslc_where");
		DebugLocation(47, 1);
		try
		{
			// ../Grammars/OslcWhere.g:47:15: ( compound_term )
			DebugEnterAlt(1);
			// ../Grammars/OslcWhere.g:47:17: compound_term
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(47, 17);
			PushFollow(Follow._compound_term_in_oslc_where105);
			compound_term1=compound_term();
			PopFollow();

			adaptor.AddChild(root_0, compound_term1.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("oslc_where", 1);
			LeaveRule("oslc_where", 1);
			LeaveRule_oslc_where();
		}
		DebugLocation(48, 1);
		} finally { DebugExitRule(GrammarFileName, "oslc_where"); }
		return retval;

	}
	// $ANTLR end "oslc_where"

	partial void EnterRule_compound_term();
	partial void LeaveRule_compound_term();
	// $ANTLR start "compound_term"
	// ../Grammars/OslcWhere.g:50:1: compound_term : simple_term ( boolean_op simple_term )* -> ^( 'terms' simple_term ( simple_term )* ) ;
	[GrammarRule("compound_term")]
	private AstParserRuleReturnScope<object, IToken> compound_term()
	{
		EnterRule_compound_term();
		EnterRule("compound_term", 2);
		TraceIn("compound_term", 2);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> simple_term2 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> boolean_op3 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> simple_term4 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_boolean_op=new RewriteRuleSubtreeStream(adaptor,"rule boolean_op");
		RewriteRuleSubtreeStream stream_simple_term=new RewriteRuleSubtreeStream(adaptor,"rule simple_term");
		try { DebugEnterRule(GrammarFileName, "compound_term");
		DebugLocation(50, 1);
		try
		{
			// ../Grammars/OslcWhere.g:50:15: ( simple_term ( boolean_op simple_term )* -> ^( 'terms' simple_term ( simple_term )* ) )
			DebugEnterAlt(1);
			// ../Grammars/OslcWhere.g:50:17: simple_term ( boolean_op simple_term )*
			{
			DebugLocation(50, 17);
			PushFollow(Follow._simple_term_in_compound_term116);
			simple_term2=simple_term();
			PopFollow();

			stream_simple_term.Add(simple_term2.Tree);
			DebugLocation(50, 29);
			// ../Grammars/OslcWhere.g:50:29: ( boolean_op simple_term )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_1 = input.LA(1);

				if ((LA1_1==51))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// ../Grammars/OslcWhere.g:50:31: boolean_op simple_term
					{
					DebugLocation(50, 31);
					PushFollow(Follow._boolean_op_in_compound_term120);
					boolean_op3=boolean_op();
					PopFollow();

					stream_boolean_op.Add(boolean_op3.Tree);
					DebugLocation(50, 42);
					PushFollow(Follow._simple_term_in_compound_term122);
					simple_term4=simple_term();
					PopFollow();

					stream_simple_term.Add(simple_term4.Tree);

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }



			{
			// AST REWRITE
			// elements: TERMS, simple_term, simple_term
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 50:57: -> ^( 'terms' simple_term ( simple_term )* )
			{
				DebugLocation(50, 60);
				// ../Grammars/OslcWhere.g:50:60: ^( 'terms' simple_term ( simple_term )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(50, 63);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(TERMS, "TERMS"), root_1);

				DebugLocation(50, 71);
				adaptor.AddChild(root_1, stream_simple_term.NextTree());
				DebugLocation(50, 83);
				// ../Grammars/OslcWhere.g:50:83: ( simple_term )*
				while ( stream_simple_term.HasNext )
				{
					DebugLocation(50, 84);
					adaptor.AddChild(root_1, stream_simple_term.NextTree());

				}
				stream_simple_term.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("compound_term", 2);
			LeaveRule("compound_term", 2);
			LeaveRule_compound_term();
		}
		DebugLocation(51, 1);
		} finally { DebugExitRule(GrammarFileName, "compound_term"); }
		return retval;

	}
	// $ANTLR end "compound_term"

	partial void EnterRule_simple_term();
	partial void LeaveRule_simple_term();
	// $ANTLR start "simple_term"
	// ../Grammars/OslcWhere.g:53:1: simple_term : ( term | scoped_term );
	[GrammarRule("simple_term")]
	private AstParserRuleReturnScope<object, IToken> simple_term()
	{
		EnterRule_simple_term();
		EnterRule("simple_term", 3);
		TraceIn("simple_term", 3);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> term5 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> scoped_term6 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "simple_term");
		DebugLocation(53, 1);
		try
		{
			// ../Grammars/OslcWhere.g:53:15: ( term | scoped_term )
			int alt2=2;
			try { DebugEnterDecision(2, false);
			int LA2_1 = input.LA(1);

			if (((LA2_1>=PNAME_LN && LA2_1<=PNAME_NS)))
			{
				int LA2_2 = input.LA(2);

				if (((LA2_2>=EQUAL && LA2_2<=GREATER_EQUAL)||(LA2_2>=LESS && LA2_2<=LESS_EQUAL)||LA2_2==NOT_EQUAL||LA2_2==52))
				{
					alt2 = 1;
				}
				else if ((LA2_2==OPEN_CURLY_BRACE))
				{
					alt2 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 2, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA2_1==ASTERISK))
			{
				int LA2_2 = input.LA(2);

				if (((LA2_2>=EQUAL && LA2_2<=GREATER_EQUAL)||(LA2_2>=LESS && LA2_2<=LESS_EQUAL)||LA2_2==NOT_EQUAL||LA2_2==52))
				{
					alt2 = 1;
				}
				else if ((LA2_2==OPEN_CURLY_BRACE))
				{
					alt2 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 2, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 2, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// ../Grammars/OslcWhere.g:53:17: term
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(53, 17);
				PushFollow(Follow._term_in_simple_term153);
				term5=term();
				PopFollow();

				adaptor.AddChild(root_0, term5.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ../Grammars/OslcWhere.g:53:24: scoped_term
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(53, 24);
				PushFollow(Follow._scoped_term_in_simple_term157);
				scoped_term6=scoped_term();
				PopFollow();

				adaptor.AddChild(root_0, scoped_term6.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("simple_term", 3);
			LeaveRule("simple_term", 3);
			LeaveRule_simple_term();
		}
		DebugLocation(54, 1);
		} finally { DebugExitRule(GrammarFileName, "simple_term"); }
		return retval;

	}
	// $ANTLR end "simple_term"

	partial void EnterRule_space();
	partial void LeaveRule_space();
	// $ANTLR start "space"
	// ../Grammars/OslcWhere.g:56:1: space : ' ' !;
	[GrammarRule("space")]
	private AstParserRuleReturnScope<object, IToken> space()
	{
		EnterRule_space();
		EnterRule("space", 4);
		TraceIn("space", 4);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal7 = default(IToken);

		object char_literal7_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "space");
		DebugLocation(56, 21);
		try
		{
			// ../Grammars/OslcWhere.g:56:15: ( ' ' !)
			DebugEnterAlt(1);
			// ../Grammars/OslcWhere.g:56:17: ' ' !
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(56, 20);
			char_literal7=(IToken)Match(input,50,Follow._50_in_space177); 

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("space", 4);
			LeaveRule("space", 4);
			LeaveRule_space();
		}
		DebugLocation(56, 21);
		} finally { DebugExitRule(GrammarFileName, "space"); }
		return retval;

	}
	// $ANTLR end "space"

	partial void EnterRule_boolean_op();
	partial void LeaveRule_boolean_op();
	// $ANTLR start "boolean_op"
	// ../Grammars/OslcWhere.g:58:1: boolean_op : ' and ' !;
	[GrammarRule("boolean_op")]
	private AstParserRuleReturnScope<object, IToken> boolean_op()
	{
		EnterRule_boolean_op();
		EnterRule("boolean_op", 5);
		TraceIn("boolean_op", 5);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal8 = default(IToken);

		object string_literal8_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "boolean_op");
		DebugLocation(58, 25);
		try
		{
			// ../Grammars/OslcWhere.g:58:15: ( ' and ' !)
			DebugEnterAlt(1);
			// ../Grammars/OslcWhere.g:58:17: ' and ' !
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(58, 24);
			string_literal8=(IToken)Match(input,51,Follow._51_in_boolean_op190); 

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("boolean_op", 5);
			LeaveRule("boolean_op", 5);
			LeaveRule_boolean_op();
		}
		DebugLocation(58, 25);
		} finally { DebugExitRule(GrammarFileName, "boolean_op"); }
		return retval;

	}
	// $ANTLR end "boolean_op"

	partial void EnterRule_term();
	partial void LeaveRule_term();
	// $ANTLR start "term"
	// ../Grammars/OslcWhere.g:60:1: term : ( term_simple | in_term );
	[GrammarRule("term")]
	private AstParserRuleReturnScope<object, IToken> term()
	{
		EnterRule_term();
		EnterRule("term", 6);
		TraceIn("term", 6);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> term_simple9 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> in_term10 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "term");
		DebugLocation(60, 29);
		try
		{
			// ../Grammars/OslcWhere.g:60:6: ( term_simple | in_term )
			int alt3=2;
			try { DebugEnterDecision(3, false);
			int LA3_1 = input.LA(1);

			if (((LA3_1>=PNAME_LN && LA3_1<=PNAME_NS)))
			{
				int LA3_2 = input.LA(2);

				if (((LA3_2>=EQUAL && LA3_2<=GREATER_EQUAL)||(LA3_2>=LESS && LA3_2<=LESS_EQUAL)||LA3_2==NOT_EQUAL))
				{
					alt3 = 1;
				}
				else if ((LA3_2==52))
				{
					alt3 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 3, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA3_1==ASTERISK))
			{
				int LA3_2 = input.LA(2);

				if (((LA3_2>=EQUAL && LA3_2<=GREATER_EQUAL)||(LA3_2>=LESS && LA3_2<=LESS_EQUAL)||LA3_2==NOT_EQUAL))
				{
					alt3 = 1;
				}
				else if ((LA3_2==52))
				{
					alt3 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 3, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 3, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// ../Grammars/OslcWhere.g:60:8: term_simple
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(60, 8);
				PushFollow(Follow._term_simple_in_term200);
				term_simple9=term_simple();
				PopFollow();

				adaptor.AddChild(root_0, term_simple9.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ../Grammars/OslcWhere.g:60:22: in_term
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(60, 22);
				PushFollow(Follow._in_term_in_term204);
				in_term10=in_term();
				PopFollow();

				adaptor.AddChild(root_0, in_term10.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("term", 6);
			LeaveRule("term", 6);
			LeaveRule_term();
		}
		DebugLocation(60, 29);
		} finally { DebugExitRule(GrammarFileName, "term"); }
		return retval;

	}
	// $ANTLR end "term"

	partial void EnterRule_term_simple();
	partial void LeaveRule_term_simple();
	// $ANTLR start "term_simple"
	// ../Grammars/OslcWhere.g:62:1: term_simple : identifier_wc comparison_op value -> ^( 'simple_term' identifier_wc comparison_op value ) ;
	[GrammarRule("term_simple")]
	private AstParserRuleReturnScope<object, IToken> term_simple()
	{
		EnterRule_term_simple();
		EnterRule("term_simple", 7);
		TraceIn("term_simple", 7);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> identifier_wc11 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> comparison_op12 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> value13 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_value=new RewriteRuleSubtreeStream(adaptor,"rule value");
		RewriteRuleSubtreeStream stream_identifier_wc=new RewriteRuleSubtreeStream(adaptor,"rule identifier_wc");
		RewriteRuleSubtreeStream stream_comparison_op=new RewriteRuleSubtreeStream(adaptor,"rule comparison_op");
		try { DebugEnterRule(GrammarFileName, "term_simple");
		DebugLocation(62, 1);
		try
		{
			// ../Grammars/OslcWhere.g:63:2: ( identifier_wc comparison_op value -> ^( 'simple_term' identifier_wc comparison_op value ) )
			DebugEnterAlt(1);
			// ../Grammars/OslcWhere.g:63:4: identifier_wc comparison_op value
			{
			DebugLocation(63, 4);
			PushFollow(Follow._identifier_wc_in_term_simple214);
			identifier_wc11=identifier_wc();
			PopFollow();

			stream_identifier_wc.Add(identifier_wc11.Tree);
			DebugLocation(63, 18);
			PushFollow(Follow._comparison_op_in_term_simple216);
			comparison_op12=comparison_op();
			PopFollow();

			stream_comparison_op.Add(comparison_op12.Tree);
			DebugLocation(63, 32);
			PushFollow(Follow._value_in_term_simple218);
			value13=value();
			PopFollow();

			stream_value.Add(value13.Tree);


			{
			// AST REWRITE
			// elements: comparison_op, SIMPLE_TERM, value, identifier_wc
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 63:38: -> ^( 'simple_term' identifier_wc comparison_op value )
			{
				DebugLocation(63, 41);
				// ../Grammars/OslcWhere.g:63:41: ^( 'simple_term' identifier_wc comparison_op value )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(63, 44);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(SIMPLE_TERM, "SIMPLE_TERM"), root_1);

				DebugLocation(63, 58);
				adaptor.AddChild(root_1, stream_identifier_wc.NextTree());
				DebugLocation(63, 72);
				adaptor.AddChild(root_1, stream_comparison_op.NextTree());
				DebugLocation(63, 86);
				adaptor.AddChild(root_1, stream_value.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("term_simple", 7);
			LeaveRule("term_simple", 7);
			LeaveRule_term_simple();
		}
		DebugLocation(64, 1);
		} finally { DebugExitRule(GrammarFileName, "term_simple"); }
		return retval;

	}
	// $ANTLR end "term_simple"

	partial void EnterRule_in_term();
	partial void LeaveRule_in_term();
	// $ANTLR start "in_term"
	// ../Grammars/OslcWhere.g:66:1: in_term : identifier_wc in_op ( space )? in_val -> ^( 'in_term' identifier_wc in_val ) ;
	[GrammarRule("in_term")]
	private AstParserRuleReturnScope<object, IToken> in_term()
	{
		EnterRule_in_term();
		EnterRule("in_term", 8);
		TraceIn("in_term", 8);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> identifier_wc14 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> in_op15 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> space16 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> in_val17 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_identifier_wc=new RewriteRuleSubtreeStream(adaptor,"rule identifier_wc");
		RewriteRuleSubtreeStream stream_space=new RewriteRuleSubtreeStream(adaptor,"rule space");
		RewriteRuleSubtreeStream stream_in_val=new RewriteRuleSubtreeStream(adaptor,"rule in_val");
		RewriteRuleSubtreeStream stream_in_op=new RewriteRuleSubtreeStream(adaptor,"rule in_op");
		try { DebugEnterRule(GrammarFileName, "in_term");
		DebugLocation(66, 1);
		try
		{
			// ../Grammars/OslcWhere.g:66:9: ( identifier_wc in_op ( space )? in_val -> ^( 'in_term' identifier_wc in_val ) )
			DebugEnterAlt(1);
			// ../Grammars/OslcWhere.g:66:11: identifier_wc in_op ( space )? in_val
			{
			DebugLocation(66, 11);
			PushFollow(Follow._identifier_wc_in_in_term243);
			identifier_wc14=identifier_wc();
			PopFollow();

			stream_identifier_wc.Add(identifier_wc14.Tree);
			DebugLocation(66, 25);
			PushFollow(Follow._in_op_in_in_term245);
			in_op15=in_op();
			PopFollow();

			stream_in_op.Add(in_op15.Tree);
			DebugLocation(66, 31);
			// ../Grammars/OslcWhere.g:66:31: ( space )?
			int alt4=2;
			try { DebugEnterSubRule(4);
			try { DebugEnterDecision(4, false);
			int LA4_1 = input.LA(1);

			if ((LA4_1==50))
			{
				alt4 = 1;
			}
			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// ../Grammars/OslcWhere.g:66:31: space
				{
				DebugLocation(66, 31);
				PushFollow(Follow._space_in_in_term247);
				space16=space();
				PopFollow();

				stream_space.Add(space16.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(4); }

			DebugLocation(66, 38);
			PushFollow(Follow._in_val_in_in_term250);
			in_val17=in_val();
			PopFollow();

			stream_in_val.Add(in_val17.Tree);


			{
			// AST REWRITE
			// elements: in_val, IN_TERM, identifier_wc
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 66:45: -> ^( 'in_term' identifier_wc in_val )
			{
				DebugLocation(66, 48);
				// ../Grammars/OslcWhere.g:66:48: ^( 'in_term' identifier_wc in_val )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(66, 51);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(IN_TERM, "IN_TERM"), root_1);

				DebugLocation(66, 61);
				adaptor.AddChild(root_1, stream_identifier_wc.NextTree());
				DebugLocation(66, 75);
				adaptor.AddChild(root_1, stream_in_val.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("in_term", 8);
			LeaveRule("in_term", 8);
			LeaveRule_in_term();
		}
		DebugLocation(67, 1);
		} finally { DebugExitRule(GrammarFileName, "in_term"); }
		return retval;

	}
	// $ANTLR end "in_term"

	partial void EnterRule_scoped_term();
	partial void LeaveRule_scoped_term();
	// $ANTLR start "scoped_term"
	// ../Grammars/OslcWhere.g:70:1: scoped_term : identifier_wc '{' compound_term '}' -> ^( 'compound_term' identifier_wc compound_term ) ;
	[GrammarRule("scoped_term")]
	private AstParserRuleReturnScope<object, IToken> scoped_term()
	{
		EnterRule_scoped_term();
		EnterRule("scoped_term", 9);
		TraceIn("scoped_term", 9);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal19 = default(IToken);
		IToken char_literal21 = default(IToken);
		AstParserRuleReturnScope<object, IToken> identifier_wc18 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> compound_term20 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal19_tree = default(object);
		object char_literal21_tree = default(object);
		RewriteRuleITokenStream stream_CLOSE_CURLY_BRACE=new RewriteRuleITokenStream(adaptor,"token CLOSE_CURLY_BRACE");
		RewriteRuleITokenStream stream_OPEN_CURLY_BRACE=new RewriteRuleITokenStream(adaptor,"token OPEN_CURLY_BRACE");
		RewriteRuleSubtreeStream stream_compound_term=new RewriteRuleSubtreeStream(adaptor,"rule compound_term");
		RewriteRuleSubtreeStream stream_identifier_wc=new RewriteRuleSubtreeStream(adaptor,"rule identifier_wc");
		try { DebugEnterRule(GrammarFileName, "scoped_term");
		DebugLocation(70, 1);
		try
		{
			// ../Grammars/OslcWhere.g:70:15: ( identifier_wc '{' compound_term '}' -> ^( 'compound_term' identifier_wc compound_term ) )
			DebugEnterAlt(1);
			// ../Grammars/OslcWhere.g:70:17: identifier_wc '{' compound_term '}'
			{
			DebugLocation(70, 17);
			PushFollow(Follow._identifier_wc_in_scoped_term275);
			identifier_wc18=identifier_wc();
			PopFollow();

			stream_identifier_wc.Add(identifier_wc18.Tree);
			DebugLocation(70, 31);
			char_literal19=(IToken)Match(input,OPEN_CURLY_BRACE,Follow._OPEN_CURLY_BRACE_in_scoped_term277);  
			stream_OPEN_CURLY_BRACE.Add(char_literal19);

			DebugLocation(70, 35);
			PushFollow(Follow._compound_term_in_scoped_term279);
			compound_term20=compound_term();
			PopFollow();

			stream_compound_term.Add(compound_term20.Tree);
			DebugLocation(70, 49);
			char_literal21=(IToken)Match(input,CLOSE_CURLY_BRACE,Follow._CLOSE_CURLY_BRACE_in_scoped_term281);  
			stream_CLOSE_CURLY_BRACE.Add(char_literal21);



			{
			// AST REWRITE
			// elements: COMPOUND_TERM, compound_term, identifier_wc
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 70:53: -> ^( 'compound_term' identifier_wc compound_term )
			{
				DebugLocation(70, 56);
				// ../Grammars/OslcWhere.g:70:56: ^( 'compound_term' identifier_wc compound_term )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(70, 59);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(COMPOUND_TERM, "COMPOUND_TERM"), root_1);

				DebugLocation(70, 75);
				adaptor.AddChild(root_1, stream_identifier_wc.NextTree());
				DebugLocation(70, 90);
				adaptor.AddChild(root_1, stream_compound_term.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("scoped_term", 9);
			LeaveRule("scoped_term", 9);
			LeaveRule_scoped_term();
		}
		DebugLocation(71, 1);
		} finally { DebugExitRule(GrammarFileName, "scoped_term"); }
		return retval;

	}
	// $ANTLR end "scoped_term"

	partial void EnterRule_identifier_wc();
	partial void LeaveRule_identifier_wc();
	// $ANTLR start "identifier_wc"
	// ../Grammars/OslcWhere.g:73:1: identifier_wc : ( identifier | wildcard );
	[GrammarRule("identifier_wc")]
	private AstParserRuleReturnScope<object, IToken> identifier_wc()
	{
		EnterRule_identifier_wc();
		EnterRule("identifier_wc", 10);
		TraceIn("identifier_wc", 10);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> identifier22 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> wildcard23 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "identifier_wc");
		DebugLocation(73, 38);
		try
		{
			// ../Grammars/OslcWhere.g:73:15: ( identifier | wildcard )
			int alt5=2;
			try { DebugEnterDecision(5, false);
			int LA5_1 = input.LA(1);

			if (((LA5_1>=PNAME_LN && LA5_1<=PNAME_NS)))
			{
				alt5 = 1;
			}
			else if ((LA5_1==ASTERISK))
			{
				alt5 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 5, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// ../Grammars/OslcWhere.g:73:17: identifier
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(73, 17);
				PushFollow(Follow._identifier_in_identifier_wc304);
				identifier22=identifier();
				PopFollow();

				adaptor.AddChild(root_0, identifier22.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ../Grammars/OslcWhere.g:73:30: wildcard
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(73, 30);
				PushFollow(Follow._wildcard_in_identifier_wc308);
				wildcard23=wildcard();
				PopFollow();

				adaptor.AddChild(root_0, wildcard23.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("identifier_wc", 10);
			LeaveRule("identifier_wc", 10);
			LeaveRule_identifier_wc();
		}
		DebugLocation(73, 38);
		} finally { DebugExitRule(GrammarFileName, "identifier_wc"); }
		return retval;

	}
	// $ANTLR end "identifier_wc"

	partial void EnterRule_identifier();
	partial void LeaveRule_identifier();
	// $ANTLR start "identifier"
	// ../Grammars/OslcWhere.g:75:1: identifier : prefixedName ;
	[GrammarRule("identifier")]
	private AstParserRuleReturnScope<object, IToken> identifier()
	{
		EnterRule_identifier();
		EnterRule("identifier", 11);
		TraceIn("identifier", 11);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> prefixedName24 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "identifier");
		DebugLocation(75, 29);
		try
		{
			// ../Grammars/OslcWhere.g:75:15: ( prefixedName )
			DebugEnterAlt(1);
			// ../Grammars/OslcWhere.g:75:17: prefixedName
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(75, 17);
			PushFollow(Follow._prefixedName_in_identifier320);
			prefixedName24=prefixedName();
			PopFollow();

			adaptor.AddChild(root_0, prefixedName24.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("identifier", 11);
			LeaveRule("identifier", 11);
			LeaveRule_identifier();
		}
		DebugLocation(75, 29);
		} finally { DebugExitRule(GrammarFileName, "identifier"); }
		return retval;

	}
	// $ANTLR end "identifier"

	partial void EnterRule_wildcard();
	partial void LeaveRule_wildcard();
	// $ANTLR start "wildcard"
	// ../Grammars/OslcWhere.g:77:1: wildcard : ASTERISK ;
	[GrammarRule("wildcard")]
	private AstParserRuleReturnScope<object, IToken> wildcard()
	{
		EnterRule_wildcard();
		EnterRule("wildcard", 12);
		TraceIn("wildcard", 12);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ASTERISK25 = default(IToken);

		object ASTERISK25_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "wildcard");
		DebugLocation(77, 25);
		try
		{
			// ../Grammars/OslcWhere.g:77:15: ( ASTERISK )
			DebugEnterAlt(1);
			// ../Grammars/OslcWhere.g:77:17: ASTERISK
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(77, 17);
			ASTERISK25=(IToken)Match(input,ASTERISK,Follow._ASTERISK_in_wildcard334); 
			ASTERISK25_tree = (object)adaptor.Create(ASTERISK25);
			adaptor.AddChild(root_0, ASTERISK25_tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("wildcard", 12);
			LeaveRule("wildcard", 12);
			LeaveRule_wildcard();
		}
		DebugLocation(77, 25);
		} finally { DebugExitRule(GrammarFileName, "wildcard"); }
		return retval;

	}
	// $ANTLR end "wildcard"

	partial void EnterRule_comparison_op();
	partial void LeaveRule_comparison_op();
	// $ANTLR start "comparison_op"
	// ../Grammars/OslcWhere.g:79:1: comparison_op : ( '=' | '!=' | '<' | '>' | '<=' | '>=' );
	[GrammarRule("comparison_op")]
	private AstParserRuleReturnScope<object, IToken> comparison_op()
	{
		EnterRule_comparison_op();
		EnterRule("comparison_op", 13);
		TraceIn("comparison_op", 13);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set26 = default(IToken);

		object set26_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "comparison_op");
		DebugLocation(79, 53);
		try
		{
			// ../Grammars/OslcWhere.g:79:15: ( '=' | '!=' | '<' | '>' | '<=' | '>=' )
			DebugEnterAlt(1);
			// ../Grammars/OslcWhere.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(79, 15);

			set26=(IToken)input.LT(1);
			if ((input.LA(1)>=EQUAL && input.LA(1)<=GREATER_EQUAL)||(input.LA(1)>=LESS && input.LA(1)<=LESS_EQUAL)||input.LA(1)==NOT_EQUAL)
			{
				input.Consume();
				adaptor.AddChild(root_0, (object)adaptor.Create(set26));
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("comparison_op", 13);
			LeaveRule("comparison_op", 13);
			LeaveRule_comparison_op();
		}
		DebugLocation(79, 53);
		} finally { DebugExitRule(GrammarFileName, "comparison_op"); }
		return retval;

	}
	// $ANTLR end "comparison_op"

	partial void EnterRule_in_op();
	partial void LeaveRule_in_op();
	// $ANTLR start "in_op"
	// ../Grammars/OslcWhere.g:81:1: in_op : ' in' ;
	[GrammarRule("in_op")]
	private AstParserRuleReturnScope<object, IToken> in_op()
	{
		EnterRule_in_op();
		EnterRule("in_op", 14);
		TraceIn("in_op", 14);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal27 = default(IToken);

		object string_literal27_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "in_op");
		DebugLocation(81, 22);
		try
		{
			// ../Grammars/OslcWhere.g:81:15: ( ' in' )
			DebugEnterAlt(1);
			// ../Grammars/OslcWhere.g:81:17: ' in'
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(81, 17);
			string_literal27=(IToken)Match(input,52,Follow._52_in_in_op380); 
			string_literal27_tree = (object)adaptor.Create(string_literal27);
			adaptor.AddChild(root_0, string_literal27_tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("in_op", 14);
			LeaveRule("in_op", 14);
			LeaveRule_in_op();
		}
		DebugLocation(81, 22);
		} finally { DebugExitRule(GrammarFileName, "in_op"); }
		return retval;

	}
	// $ANTLR end "in_op"

	partial void EnterRule_in_val();
	partial void LeaveRule_in_val();
	// $ANTLR start "in_val"
	// ../Grammars/OslcWhere.g:83:1: in_val : '[' value ( ',' value )* ']' -> ^( 'in_values' value ( value )* ) ;
	[GrammarRule("in_val")]
	private AstParserRuleReturnScope<object, IToken> in_val()
	{
		EnterRule_in_val();
		EnterRule("in_val", 15);
		TraceIn("in_val", 15);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal28 = default(IToken);
		IToken char_literal30 = default(IToken);
		IToken char_literal32 = default(IToken);
		AstParserRuleReturnScope<object, IToken> value29 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> value31 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal28_tree = default(object);
		object char_literal30_tree = default(object);
		object char_literal32_tree = default(object);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleITokenStream stream_OPEN_SQUARE_BRACE=new RewriteRuleITokenStream(adaptor,"token OPEN_SQUARE_BRACE");
		RewriteRuleITokenStream stream_CLOSE_SQUARE_BRACE=new RewriteRuleITokenStream(adaptor,"token CLOSE_SQUARE_BRACE");
		RewriteRuleSubtreeStream stream_value=new RewriteRuleSubtreeStream(adaptor,"rule value");
		try { DebugEnterRule(GrammarFileName, "in_val");
		DebugLocation(83, 1);
		try
		{
			// ../Grammars/OslcWhere.g:83:15: ( '[' value ( ',' value )* ']' -> ^( 'in_values' value ( value )* ) )
			DebugEnterAlt(1);
			// ../Grammars/OslcWhere.g:83:17: '[' value ( ',' value )* ']'
			{
			DebugLocation(83, 17);
			char_literal28=(IToken)Match(input,OPEN_SQUARE_BRACE,Follow._OPEN_SQUARE_BRACE_in_in_val396);  
			stream_OPEN_SQUARE_BRACE.Add(char_literal28);

			DebugLocation(83, 21);
			PushFollow(Follow._value_in_in_val398);
			value29=value();
			PopFollow();

			stream_value.Add(value29.Tree);
			DebugLocation(83, 27);
			// ../Grammars/OslcWhere.g:83:27: ( ',' value )*
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, false);
				int LA6_1 = input.LA(1);

				if ((LA6_1==COMMA))
				{
					alt6 = 1;
				}


				} finally { DebugExitDecision(6); }
				switch ( alt6 )
				{
				case 1:
					DebugEnterAlt(1);
					// ../Grammars/OslcWhere.g:83:28: ',' value
					{
					DebugLocation(83, 28);
					char_literal30=(IToken)Match(input,COMMA,Follow._COMMA_in_in_val401);  
					stream_COMMA.Add(char_literal30);

					DebugLocation(83, 32);
					PushFollow(Follow._value_in_in_val403);
					value31=value();
					PopFollow();

					stream_value.Add(value31.Tree);

					}
					break;

				default:
					goto loop6;
				}
			}

			loop6:
				;

			} finally { DebugExitSubRule(6); }

			DebugLocation(83, 40);
			char_literal32=(IToken)Match(input,CLOSE_SQUARE_BRACE,Follow._CLOSE_SQUARE_BRACE_in_in_val407);  
			stream_CLOSE_SQUARE_BRACE.Add(char_literal32);



			{
			// AST REWRITE
			// elements: value, IN_VALUES, value
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 83:44: -> ^( 'in_values' value ( value )* )
			{
				DebugLocation(83, 47);
				// ../Grammars/OslcWhere.g:83:47: ^( 'in_values' value ( value )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(83, 50);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(IN_VALUES, "IN_VALUES"), root_1);

				DebugLocation(83, 62);
				adaptor.AddChild(root_1, stream_value.NextTree());
				DebugLocation(83, 68);
				// ../Grammars/OslcWhere.g:83:68: ( value )*
				while ( stream_value.HasNext )
				{
					DebugLocation(83, 69);
					adaptor.AddChild(root_1, stream_value.NextTree());

				}
				stream_value.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("in_val", 15);
			LeaveRule("in_val", 15);
			LeaveRule_in_val();
		}
		DebugLocation(84, 1);
		} finally { DebugExitRule(GrammarFileName, "in_val"); }
		return retval;

	}
	// $ANTLR end "in_val"

	partial void EnterRule_value();
	partial void LeaveRule_value();
	// $ANTLR start "value"
	// ../Grammars/OslcWhere.g:86:1: value : ( iriRef | literal_value );
	[GrammarRule("value")]
	private AstParserRuleReturnScope<object, IToken> value()
	{
		EnterRule_value();
		EnterRule("value", 16);
		TraceIn("value", 16);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> iriRef33 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> literal_value34 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "value");
		DebugLocation(86, 39);
		try
		{
			// ../Grammars/OslcWhere.g:86:15: ( iriRef | literal_value )
			int alt7=2;
			try { DebugEnterDecision(7, false);
			int LA7_1 = input.LA(1);

			if ((LA7_1==IRI_REF||(LA7_1>=PNAME_LN && LA7_1<=PNAME_NS)))
			{
				alt7 = 1;
			}
			else if ((LA7_1==BOOLEAN||LA7_1==DECIMAL||LA7_1==STRING_LITERAL))
			{
				alt7 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 7, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// ../Grammars/OslcWhere.g:86:17: iriRef
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(86, 17);
				PushFollow(Follow._iriRef_in_value440);
				iriRef33=iriRef();
				PopFollow();

				adaptor.AddChild(root_0, iriRef33.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ../Grammars/OslcWhere.g:86:26: literal_value
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(86, 26);
				PushFollow(Follow._literal_value_in_value444);
				literal_value34=literal_value();
				PopFollow();

				adaptor.AddChild(root_0, literal_value34.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("value", 16);
			LeaveRule("value", 16);
			LeaveRule_value();
		}
		DebugLocation(86, 39);
		} finally { DebugExitRule(GrammarFileName, "value"); }
		return retval;

	}
	// $ANTLR end "value"

	partial void EnterRule_literal_value();
	partial void LeaveRule_literal_value();
	// $ANTLR start "literal_value"
	// ../Grammars/OslcWhere.g:88:1: literal_value : ( boolean_val | decimal | string_esc | typed_string | langed_string );
	[GrammarRule("literal_value")]
	private AstParserRuleReturnScope<object, IToken> literal_value()
	{
		EnterRule_literal_value();
		EnterRule("literal_value", 17);
		TraceIn("literal_value", 17);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> boolean_val35 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> decimal36 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> string_esc37 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> typed_string38 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> langed_string39 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "literal_value");
		DebugLocation(88, 1);
		try
		{
			// ../Grammars/OslcWhere.g:88:15: ( boolean_val | decimal | string_esc | typed_string | langed_string )
			int alt8=5;
			try { DebugEnterDecision(8, false);
			switch (input.LA(1))
			{
			case BOOLEAN:
				{
				alt8 = 1;
				}
				break;
			case DECIMAL:
				{
				alt8 = 2;
				}
				break;
			case STRING_LITERAL:
				{
				switch (input.LA(2))
				{
				case EOF:
				case CLOSE_CURLY_BRACE:
				case CLOSE_SQUARE_BRACE:
				case COMMA:
				case 51:
					{
					alt8 = 3;
					}
					break;
				case REFERENCE:
					{
					alt8 = 4;
					}
					break;
				case LANGTAG:
					{
					alt8 = 5;
					}
					break;
				default:
					{
						NoViableAltException nvae = new NoViableAltException("", 8, 3, input, 2);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 8, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// ../Grammars/OslcWhere.g:88:17: boolean_val
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(88, 17);
				PushFollow(Follow._boolean_val_in_literal_value453);
				boolean_val35=boolean_val();
				PopFollow();

				adaptor.AddChild(root_0, boolean_val35.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ../Grammars/OslcWhere.g:88:31: decimal
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(88, 31);
				PushFollow(Follow._decimal_in_literal_value457);
				decimal36=@decimal();
				PopFollow();

				adaptor.AddChild(root_0, decimal36.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// ../Grammars/OslcWhere.g:88:41: string_esc
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(88, 41);
				PushFollow(Follow._string_esc_in_literal_value461);
				string_esc37=string_esc();
				PopFollow();

				adaptor.AddChild(root_0, string_esc37.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// ../Grammars/OslcWhere.g:88:54: typed_string
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(88, 54);
				PushFollow(Follow._typed_string_in_literal_value465);
				typed_string38=typed_string();
				PopFollow();

				adaptor.AddChild(root_0, typed_string38.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// ../Grammars/OslcWhere.g:88:70: langed_string
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(88, 70);
				PushFollow(Follow._langed_string_in_literal_value470);
				langed_string39=langed_string();
				PopFollow();

				adaptor.AddChild(root_0, langed_string39.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("literal_value", 17);
			LeaveRule("literal_value", 17);
			LeaveRule_literal_value();
		}
		DebugLocation(89, 1);
		} finally { DebugExitRule(GrammarFileName, "literal_value"); }
		return retval;

	}
	// $ANTLR end "literal_value"

	partial void EnterRule_typed_string();
	partial void LeaveRule_typed_string();
	// $ANTLR start "typed_string"
	// ../Grammars/OslcWhere.g:91:1: typed_string : string_esc ( '^^' prefixedName ) -> ^( 'typed_value' string_esc ( prefixedName )? ) ;
	[GrammarRule("typed_string")]
	private AstParserRuleReturnScope<object, IToken> typed_string()
	{
		EnterRule_typed_string();
		EnterRule("typed_string", 18);
		TraceIn("typed_string", 18);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal41 = default(IToken);
		AstParserRuleReturnScope<object, IToken> string_esc40 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> prefixedName42 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal41_tree = default(object);
		RewriteRuleITokenStream stream_REFERENCE=new RewriteRuleITokenStream(adaptor,"token REFERENCE");
		RewriteRuleSubtreeStream stream_string_esc=new RewriteRuleSubtreeStream(adaptor,"rule string_esc");
		RewriteRuleSubtreeStream stream_prefixedName=new RewriteRuleSubtreeStream(adaptor,"rule prefixedName");
		try { DebugEnterRule(GrammarFileName, "typed_string");
		DebugLocation(91, 1);
		try
		{
			// ../Grammars/OslcWhere.g:92:2: ( string_esc ( '^^' prefixedName ) -> ^( 'typed_value' string_esc ( prefixedName )? ) )
			DebugEnterAlt(1);
			// ../Grammars/OslcWhere.g:92:4: string_esc ( '^^' prefixedName )
			{
			DebugLocation(92, 4);
			PushFollow(Follow._string_esc_in_typed_string482);
			string_esc40=string_esc();
			PopFollow();

			stream_string_esc.Add(string_esc40.Tree);
			DebugLocation(92, 15);
			// ../Grammars/OslcWhere.g:92:15: ( '^^' prefixedName )
			DebugEnterAlt(1);
			// ../Grammars/OslcWhere.g:92:17: '^^' prefixedName
			{
			DebugLocation(92, 17);
			string_literal41=(IToken)Match(input,REFERENCE,Follow._REFERENCE_in_typed_string486);  
			stream_REFERENCE.Add(string_literal41);

			DebugLocation(92, 22);
			PushFollow(Follow._prefixedName_in_typed_string488);
			prefixedName42=prefixedName();
			PopFollow();

			stream_prefixedName.Add(prefixedName42.Tree);

			}



			{
			// AST REWRITE
			// elements: prefixedName, TYPED_VALUE, string_esc
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 92:37: -> ^( 'typed_value' string_esc ( prefixedName )? )
			{
				DebugLocation(92, 40);
				// ../Grammars/OslcWhere.g:92:40: ^( 'typed_value' string_esc ( prefixedName )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(92, 43);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(TYPED_VALUE, "TYPED_VALUE"), root_1);

				DebugLocation(92, 57);
				adaptor.AddChild(root_1, stream_string_esc.NextTree());
				DebugLocation(92, 68);
				// ../Grammars/OslcWhere.g:92:68: ( prefixedName )?
				if (stream_prefixedName.HasNext)
				{
					DebugLocation(92, 68);
					adaptor.AddChild(root_1, stream_prefixedName.NextTree());

				}
				stream_prefixedName.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("typed_string", 18);
			LeaveRule("typed_string", 18);
			LeaveRule_typed_string();
		}
		DebugLocation(93, 1);
		} finally { DebugExitRule(GrammarFileName, "typed_string"); }
		return retval;

	}
	// $ANTLR end "typed_string"

	partial void EnterRule_langed_string();
	partial void LeaveRule_langed_string();
	// $ANTLR start "langed_string"
	// ../Grammars/OslcWhere.g:95:1: langed_string : string_esc LANGTAG -> ^( 'langed_value' string_esc LANGTAG ) ;
	[GrammarRule("langed_string")]
	private AstParserRuleReturnScope<object, IToken> langed_string()
	{
		EnterRule_langed_string();
		EnterRule("langed_string", 19);
		TraceIn("langed_string", 19);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LANGTAG44 = default(IToken);
		AstParserRuleReturnScope<object, IToken> string_esc43 = default(AstParserRuleReturnScope<object, IToken>);

		object LANGTAG44_tree = default(object);
		RewriteRuleITokenStream stream_LANGTAG=new RewriteRuleITokenStream(adaptor,"token LANGTAG");
		RewriteRuleSubtreeStream stream_string_esc=new RewriteRuleSubtreeStream(adaptor,"rule string_esc");
		try { DebugEnterRule(GrammarFileName, "langed_string");
		DebugLocation(95, 1);
		try
		{
			// ../Grammars/OslcWhere.g:96:2: ( string_esc LANGTAG -> ^( 'langed_value' string_esc LANGTAG ) )
			DebugEnterAlt(1);
			// ../Grammars/OslcWhere.g:96:4: string_esc LANGTAG
			{
			DebugLocation(96, 4);
			PushFollow(Follow._string_esc_in_langed_string516);
			string_esc43=string_esc();
			PopFollow();

			stream_string_esc.Add(string_esc43.Tree);
			DebugLocation(96, 15);
			LANGTAG44=(IToken)Match(input,LANGTAG,Follow._LANGTAG_in_langed_string518);  
			stream_LANGTAG.Add(LANGTAG44);



			{
			// AST REWRITE
			// elements: LANGED_VALUE, string_esc, LANGTAG
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 96:24: -> ^( 'langed_value' string_esc LANGTAG )
			{
				DebugLocation(96, 27);
				// ../Grammars/OslcWhere.g:96:27: ^( 'langed_value' string_esc LANGTAG )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(96, 30);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(LANGED_VALUE, "LANGED_VALUE"), root_1);

				DebugLocation(96, 45);
				adaptor.AddChild(root_1, stream_string_esc.NextTree());
				DebugLocation(96, 56);
				adaptor.AddChild(root_1, stream_LANGTAG.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("langed_string", 19);
			LeaveRule("langed_string", 19);
			LeaveRule_langed_string();
		}
		DebugLocation(97, 1);
		} finally { DebugExitRule(GrammarFileName, "langed_string"); }
		return retval;

	}
	// $ANTLR end "langed_string"

	partial void EnterRule_boolean_val();
	partial void LeaveRule_boolean_val();
	// $ANTLR start "boolean_val"
	// ../Grammars/OslcWhere.g:100:1: boolean_val : BOOLEAN ;
	[GrammarRule("boolean_val")]
	private AstParserRuleReturnScope<object, IToken> boolean_val()
	{
		EnterRule_boolean_val();
		EnterRule("boolean_val", 20);
		TraceIn("boolean_val", 20);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken BOOLEAN45 = default(IToken);

		object BOOLEAN45_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "boolean_val");
		DebugLocation(100, 24);
		try
		{
			// ../Grammars/OslcWhere.g:100:15: ( BOOLEAN )
			DebugEnterAlt(1);
			// ../Grammars/OslcWhere.g:100:17: BOOLEAN
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(100, 17);
			BOOLEAN45=(IToken)Match(input,BOOLEAN,Follow._BOOLEAN_in_boolean_val545); 
			BOOLEAN45_tree = (object)adaptor.Create(BOOLEAN45);
			adaptor.AddChild(root_0, BOOLEAN45_tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("boolean_val", 20);
			LeaveRule("boolean_val", 20);
			LeaveRule_boolean_val();
		}
		DebugLocation(100, 24);
		} finally { DebugExitRule(GrammarFileName, "boolean_val"); }
		return retval;

	}
	// $ANTLR end "boolean_val"

	partial void EnterRule_decimal();
	partial void LeaveRule_decimal();
	// $ANTLR start "decimal"
	// ../Grammars/OslcWhere.g:102:1: decimal : DECIMAL ;
	[GrammarRule("decimal")]
	private AstParserRuleReturnScope<object, IToken> @decimal()
	{
		EnterRule_decimal();
		EnterRule("decimal", 21);
		TraceIn("decimal", 21);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken DECIMAL46 = default(IToken);

		object DECIMAL46_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "decimal");
		DebugLocation(102, 24);
		try
		{
			// ../Grammars/OslcWhere.g:102:15: ( DECIMAL )
			DebugEnterAlt(1);
			// ../Grammars/OslcWhere.g:102:17: DECIMAL
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(102, 17);
			DECIMAL46=(IToken)Match(input,DECIMAL,Follow._DECIMAL_in_decimal560); 
			DECIMAL46_tree = (object)adaptor.Create(DECIMAL46);
			adaptor.AddChild(root_0, DECIMAL46_tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("decimal", 21);
			LeaveRule("decimal", 21);
			LeaveRule_decimal();
		}
		DebugLocation(102, 24);
		} finally { DebugExitRule(GrammarFileName, "decimal"); }
		return retval;

	}
	// $ANTLR end "decimal"

	partial void EnterRule_string_esc();
	partial void LeaveRule_string_esc();
	// $ANTLR start "string_esc"
	// ../Grammars/OslcWhere.g:104:1: string_esc : STRING_LITERAL ;
	[GrammarRule("string_esc")]
	private AstParserRuleReturnScope<object, IToken> string_esc()
	{
		EnterRule_string_esc();
		EnterRule("string_esc", 22);
		TraceIn("string_esc", 22);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken STRING_LITERAL47 = default(IToken);

		object STRING_LITERAL47_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "string_esc");
		DebugLocation(104, 31);
		try
		{
			// ../Grammars/OslcWhere.g:104:15: ( STRING_LITERAL )
			DebugEnterAlt(1);
			// ../Grammars/OslcWhere.g:104:17: STRING_LITERAL
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(104, 17);
			STRING_LITERAL47=(IToken)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_string_esc572); 
			STRING_LITERAL47_tree = (object)adaptor.Create(STRING_LITERAL47);
			adaptor.AddChild(root_0, STRING_LITERAL47_tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("string_esc", 22);
			LeaveRule("string_esc", 22);
			LeaveRule_string_esc();
		}
		DebugLocation(104, 31);
		} finally { DebugExitRule(GrammarFileName, "string_esc"); }
		return retval;

	}
	// $ANTLR end "string_esc"

	partial void EnterRule_properties();
	partial void LeaveRule_properties();
	// $ANTLR start "properties"
	// ../Grammars/OslcWhere.g:106:1: properties : property ( ',' property )* ;
	[GrammarRule("properties")]
	private AstParserRuleReturnScope<object, IToken> properties()
	{
		EnterRule_properties();
		EnterRule("properties", 23);
		TraceIn("properties", 23);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal49 = default(IToken);
		AstParserRuleReturnScope<object, IToken> property48 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> property50 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal49_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "properties");
		DebugLocation(106, 1);
		try
		{
			// ../Grammars/OslcWhere.g:106:13: ( property ( ',' property )* )
			DebugEnterAlt(1);
			// ../Grammars/OslcWhere.g:107:2: property ( ',' property )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(107, 2);
			PushFollow(Follow._property_in_properties585);
			property48=property();
			PopFollow();

			adaptor.AddChild(root_0, property48.Tree);
			DebugLocation(107, 11);
			// ../Grammars/OslcWhere.g:107:11: ( ',' property )*
			try { DebugEnterSubRule(9);
			while (true)
			{
				int alt9=2;
				try { DebugEnterDecision(9, false);
				int LA9_1 = input.LA(1);

				if ((LA9_1==COMMA))
				{
					alt9 = 1;
				}


				} finally { DebugExitDecision(9); }
				switch ( alt9 )
				{
				case 1:
					DebugEnterAlt(1);
					// ../Grammars/OslcWhere.g:107:12: ',' property
					{
					DebugLocation(107, 12);
					char_literal49=(IToken)Match(input,COMMA,Follow._COMMA_in_properties588); 
					char_literal49_tree = (object)adaptor.Create(char_literal49);
					adaptor.AddChild(root_0, char_literal49_tree);
					DebugLocation(107, 16);
					PushFollow(Follow._property_in_properties590);
					property50=property();
					PopFollow();

					adaptor.AddChild(root_0, property50.Tree);

					}
					break;

				default:
					goto loop9;
				}
			}

			loop9:
				;

			} finally { DebugExitSubRule(9); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("properties", 23);
			LeaveRule("properties", 23);
			LeaveRule_properties();
		}
		DebugLocation(108, 1);
		} finally { DebugExitRule(GrammarFileName, "properties"); }
		return retval;

	}
	// $ANTLR end "properties"

	partial void EnterRule_property();
	partial void LeaveRule_property();
	// $ANTLR start "property"
	// ../Grammars/OslcWhere.g:110:1: property : prefixedName ( nested_property )* ;
	[GrammarRule("property")]
	private AstParserRuleReturnScope<object, IToken> property()
	{
		EnterRule_property();
		EnterRule("property", 24);
		TraceIn("property", 24);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> prefixedName51 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> nested_property52 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "property");
		DebugLocation(110, 1);
		try
		{
			// ../Grammars/OslcWhere.g:110:11: ( prefixedName ( nested_property )* )
			DebugEnterAlt(1);
			// ../Grammars/OslcWhere.g:111:2: prefixedName ( nested_property )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(111, 2);
			PushFollow(Follow._prefixedName_in_property607);
			prefixedName51=prefixedName();
			PopFollow();

			adaptor.AddChild(root_0, prefixedName51.Tree);
			DebugLocation(111, 15);
			// ../Grammars/OslcWhere.g:111:15: ( nested_property )*
			try { DebugEnterSubRule(10);
			while (true)
			{
				int alt10=2;
				try { DebugEnterDecision(10, false);
				int LA10_1 = input.LA(1);

				if ((LA10_1==OPEN_CURLY_BRACE))
				{
					alt10 = 1;
				}


				} finally { DebugExitDecision(10); }
				switch ( alt10 )
				{
				case 1:
					DebugEnterAlt(1);
					// ../Grammars/OslcWhere.g:111:17: nested_property
					{
					DebugLocation(111, 17);
					PushFollow(Follow._nested_property_in_property611);
					nested_property52=nested_property();
					PopFollow();

					adaptor.AddChild(root_0, nested_property52.Tree);

					}
					break;

				default:
					goto loop10;
				}
			}

			loop10:
				;

			} finally { DebugExitSubRule(10); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("property", 24);
			LeaveRule("property", 24);
			LeaveRule_property();
		}
		DebugLocation(112, 1);
		} finally { DebugExitRule(GrammarFileName, "property"); }
		return retval;

	}
	// $ANTLR end "property"

	partial void EnterRule_nested_property();
	partial void LeaveRule_nested_property();
	// $ANTLR start "nested_property"
	// ../Grammars/OslcWhere.g:114:1: nested_property : '{' property ( ',' property )* '}' ;
	[GrammarRule("nested_property")]
	private AstParserRuleReturnScope<object, IToken> nested_property()
	{
		EnterRule_nested_property();
		EnterRule("nested_property", 25);
		TraceIn("nested_property", 25);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal53 = default(IToken);
		IToken char_literal55 = default(IToken);
		IToken char_literal57 = default(IToken);
		AstParserRuleReturnScope<object, IToken> property54 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> property56 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal53_tree = default(object);
		object char_literal55_tree = default(object);
		object char_literal57_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "nested_property");
		DebugLocation(114, 1);
		try
		{
			// ../Grammars/OslcWhere.g:114:17: ( '{' property ( ',' property )* '}' )
			DebugEnterAlt(1);
			// ../Grammars/OslcWhere.g:115:2: '{' property ( ',' property )* '}'
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(115, 2);
			char_literal53=(IToken)Match(input,OPEN_CURLY_BRACE,Follow._OPEN_CURLY_BRACE_in_nested_property627); 
			char_literal53_tree = (object)adaptor.Create(char_literal53);
			adaptor.AddChild(root_0, char_literal53_tree);
			DebugLocation(115, 6);
			PushFollow(Follow._property_in_nested_property629);
			property54=property();
			PopFollow();

			adaptor.AddChild(root_0, property54.Tree);
			DebugLocation(115, 15);
			// ../Grammars/OslcWhere.g:115:15: ( ',' property )*
			try { DebugEnterSubRule(11);
			while (true)
			{
				int alt11=2;
				try { DebugEnterDecision(11, false);
				int LA11_1 = input.LA(1);

				if ((LA11_1==COMMA))
				{
					alt11 = 1;
				}


				} finally { DebugExitDecision(11); }
				switch ( alt11 )
				{
				case 1:
					DebugEnterAlt(1);
					// ../Grammars/OslcWhere.g:115:16: ',' property
					{
					DebugLocation(115, 16);
					char_literal55=(IToken)Match(input,COMMA,Follow._COMMA_in_nested_property632); 
					char_literal55_tree = (object)adaptor.Create(char_literal55);
					adaptor.AddChild(root_0, char_literal55_tree);
					DebugLocation(115, 20);
					PushFollow(Follow._property_in_nested_property634);
					property56=property();
					PopFollow();

					adaptor.AddChild(root_0, property56.Tree);

					}
					break;

				default:
					goto loop11;
				}
			}

			loop11:
				;

			} finally { DebugExitSubRule(11); }

			DebugLocation(115, 33);
			char_literal57=(IToken)Match(input,CLOSE_CURLY_BRACE,Follow._CLOSE_CURLY_BRACE_in_nested_property640); 
			char_literal57_tree = (object)adaptor.Create(char_literal57);
			adaptor.AddChild(root_0, char_literal57_tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("nested_property", 25);
			LeaveRule("nested_property", 25);
			LeaveRule_nested_property();
		}
		DebugLocation(116, 1);
		} finally { DebugExitRule(GrammarFileName, "nested_property"); }
		return retval;

	}
	// $ANTLR end "nested_property"

	partial void EnterRule_iriRef();
	partial void LeaveRule_iriRef();
	// $ANTLR start "iriRef"
	// ../Grammars/OslcWhere.g:118:1: iriRef : ( IRI_REF | prefixedName );
	[GrammarRule("iriRef")]
	private AstParserRuleReturnScope<object, IToken> iriRef()
	{
		EnterRule_iriRef();
		EnterRule("iriRef", 26);
		TraceIn("iriRef", 26);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken IRI_REF58 = default(IToken);
		AstParserRuleReturnScope<object, IToken> prefixedName59 = default(AstParserRuleReturnScope<object, IToken>);

		object IRI_REF58_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "iriRef");
		DebugLocation(118, 4);
		try
		{
			// ../Grammars/OslcWhere.g:119:5: ( IRI_REF | prefixedName )
			int alt12=2;
			try { DebugEnterDecision(12, false);
			int LA12_1 = input.LA(1);

			if ((LA12_1==IRI_REF))
			{
				alt12 = 1;
			}
			else if (((LA12_1>=PNAME_LN && LA12_1<=PNAME_NS)))
			{
				alt12 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 12, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(12); }
			switch (alt12)
			{
			case 1:
				DebugEnterAlt(1);
				// ../Grammars/OslcWhere.g:119:7: IRI_REF
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(119, 7);
				IRI_REF58=(IToken)Match(input,IRI_REF,Follow._IRI_REF_in_iriRef655); 
				IRI_REF58_tree = (object)adaptor.Create(IRI_REF58);
				adaptor.AddChild(root_0, IRI_REF58_tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ../Grammars/OslcWhere.g:120:7: prefixedName
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(120, 7);
				PushFollow(Follow._prefixedName_in_iriRef663);
				prefixedName59=prefixedName();
				PopFollow();

				adaptor.AddChild(root_0, prefixedName59.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("iriRef", 26);
			LeaveRule("iriRef", 26);
			LeaveRule_iriRef();
		}
		DebugLocation(121, 4);
		} finally { DebugExitRule(GrammarFileName, "iriRef"); }
		return retval;

	}
	// $ANTLR end "iriRef"

	partial void EnterRule_prefixedName();
	partial void LeaveRule_prefixedName();
	// $ANTLR start "prefixedName"
	// ../Grammars/OslcWhere.g:123:1: prefixedName : ( PNAME_LN | PNAME_NS );
	[GrammarRule("prefixedName")]
	private AstParserRuleReturnScope<object, IToken> prefixedName()
	{
		EnterRule_prefixedName();
		EnterRule("prefixedName", 27);
		TraceIn("prefixedName", 27);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set60 = default(IToken);

		object set60_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "prefixedName");
		DebugLocation(123, 4);
		try
		{
			// ../Grammars/OslcWhere.g:124:5: ( PNAME_LN | PNAME_NS )
			DebugEnterAlt(1);
			// ../Grammars/OslcWhere.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(124, 5);

			set60=(IToken)input.LT(1);
			if ((input.LA(1)>=PNAME_LN && input.LA(1)<=PNAME_NS))
			{
				input.Consume();
				adaptor.AddChild(root_0, (object)adaptor.Create(set60));
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("prefixedName", 27);
			LeaveRule("prefixedName", 27);
			LeaveRule_prefixedName();
		}
		DebugLocation(126, 4);
		} finally { DebugExitRule(GrammarFileName, "prefixedName"); }
		return retval;

	}
	// $ANTLR end "prefixedName"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _compound_term_in_oslc_where105 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _simple_term_in_compound_term116 = new BitSet(new ulong[]{0x8000000000002UL});
		public static readonly BitSet _boolean_op_in_compound_term120 = new BitSet(new ulong[]{0x3000000040UL});
		public static readonly BitSet _simple_term_in_compound_term122 = new BitSet(new ulong[]{0x8000000000002UL});
		public static readonly BitSet _term_in_simple_term153 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _scoped_term_in_simple_term157 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _50_in_space177 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _51_in_boolean_op190 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _term_simple_in_term200 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _in_term_in_term204 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _identifier_wc_in_term_simple214 = new BitSet(new ulong[]{0x4C1C0000UL});
		public static readonly BitSet _comparison_op_in_term_simple216 = new BitSet(new ulong[]{0x403000802080UL});
		public static readonly BitSet _value_in_term_simple218 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _identifier_wc_in_in_term243 = new BitSet(new ulong[]{0x10000000000000UL});
		public static readonly BitSet _in_op_in_in_term245 = new BitSet(new ulong[]{0x4000200000000UL});
		public static readonly BitSet _space_in_in_term247 = new BitSet(new ulong[]{0x200000000UL});
		public static readonly BitSet _in_val_in_in_term250 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _identifier_wc_in_scoped_term275 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _OPEN_CURLY_BRACE_in_scoped_term277 = new BitSet(new ulong[]{0x3000000040UL});
		public static readonly BitSet _compound_term_in_scoped_term279 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _CLOSE_CURLY_BRACE_in_scoped_term281 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _identifier_in_identifier_wc304 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _wildcard_in_identifier_wc308 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _prefixedName_in_identifier320 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ASTERISK_in_wildcard334 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _52_in_in_op380 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OPEN_SQUARE_BRACE_in_in_val396 = new BitSet(new ulong[]{0x403000802080UL});
		public static readonly BitSet _value_in_in_val398 = new BitSet(new ulong[]{0xC00UL});
		public static readonly BitSet _COMMA_in_in_val401 = new BitSet(new ulong[]{0x403000802080UL});
		public static readonly BitSet _value_in_in_val403 = new BitSet(new ulong[]{0xC00UL});
		public static readonly BitSet _CLOSE_SQUARE_BRACE_in_in_val407 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _iriRef_in_value440 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _literal_value_in_value444 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _boolean_val_in_literal_value453 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _decimal_in_literal_value457 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _string_esc_in_literal_value461 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _typed_string_in_literal_value465 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _langed_string_in_literal_value470 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _string_esc_in_typed_string482 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _REFERENCE_in_typed_string486 = new BitSet(new ulong[]{0x3000000000UL});
		public static readonly BitSet _prefixedName_in_typed_string488 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _string_esc_in_langed_string516 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _LANGTAG_in_langed_string518 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BOOLEAN_in_boolean_val545 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DECIMAL_in_decimal560 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_LITERAL_in_string_esc572 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _property_in_properties585 = new BitSet(new ulong[]{0x802UL});
		public static readonly BitSet _COMMA_in_properties588 = new BitSet(new ulong[]{0x3000000000UL});
		public static readonly BitSet _property_in_properties590 = new BitSet(new ulong[]{0x802UL});
		public static readonly BitSet _prefixedName_in_property607 = new BitSet(new ulong[]{0x100000002UL});
		public static readonly BitSet _nested_property_in_property611 = new BitSet(new ulong[]{0x100000002UL});
		public static readonly BitSet _OPEN_CURLY_BRACE_in_nested_property627 = new BitSet(new ulong[]{0x3000000000UL});
		public static readonly BitSet _property_in_nested_property629 = new BitSet(new ulong[]{0xA00UL});
		public static readonly BitSet _COMMA_in_nested_property632 = new BitSet(new ulong[]{0x3000000000UL});
		public static readonly BitSet _property_in_nested_property634 = new BitSet(new ulong[]{0xA00UL});
		public static readonly BitSet _CLOSE_CURLY_BRACE_in_nested_property640 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IRI_REF_in_iriRef655 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _prefixedName_in_iriRef663 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace  OSLC4Net.Core.Query.Impl 
