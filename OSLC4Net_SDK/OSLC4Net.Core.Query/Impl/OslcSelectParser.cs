//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5 ../Grammars/OslcSelect.g 2013-06-26 14:33:39

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace  OSLC4Net.Core.Query.Impl 
{
/******************************************************************************
 * Copyright (c) 2013 IBM Corporation.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v. 1.0 which accompanies this distribution. 
 *
 * The Eclipse Public License is available at http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at 
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors: 
 *
 *    Steve Pitchke - initial API and implementation
 *******************************************************************************/
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5")]
[System.CLSCompliant(false)]
public partial class OslcSelectParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ASTERISK", "CLOSE_CURLY_BRACE", "COMMA", "DIGIT", "DOT", "ECHAR", "EOL", "MINUS", "NESTED_PROPERTIES", "NOT", "OPEN_CURLY_BRACE", "PLUS", "PNAME_LN", "PNAME_NS", "PN_CHARS", "PN_CHARS_BASE", "PN_CHARS_U", "PN_LOCAL", "PN_PREFIX", "PREFIXED_NAME", "PROPERTIES", "WILDCARD", "WS"
	};
	public const int EOF=-1;
	public const int ASTERISK=4;
	public const int CLOSE_CURLY_BRACE=5;
	public const int COMMA=6;
	public const int DIGIT=7;
	public const int DOT=8;
	public const int ECHAR=9;
	public const int EOL=10;
	public const int MINUS=11;
	public const int NESTED_PROPERTIES=12;
	public const int NOT=13;
	public const int OPEN_CURLY_BRACE=14;
	public const int PLUS=15;
	public const int PNAME_LN=16;
	public const int PNAME_NS=17;
	public const int PN_CHARS=18;
	public const int PN_CHARS_BASE=19;
	public const int PN_CHARS_U=20;
	public const int PN_LOCAL=21;
	public const int PN_PREFIX=22;
	public const int PREFIXED_NAME=23;
	public const int PROPERTIES=24;
	public const int WILDCARD=25;
	public const int WS=26;

	public OslcSelectParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public OslcSelectParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return OslcSelectParser.tokenNames; } }
	public override string GrammarFileName { get { return "../Grammars/OslcSelect.g"; } }


	    public OslcSelectParser(string select) :
			this(new CommonTokenStream(new OslcSelectLexer(new ANTLRStringStream(select))))
	    {
	    }
		
		public object Result
		{
			get { return oslc_select().Tree; }
		}


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_oslc_select();
	partial void LeaveRule_oslc_select();
	// $ANTLR start "oslc_select"
	// ../Grammars/OslcSelect.g:44:1: oslc_select : properties ;
	[GrammarRule("oslc_select")]
	private AstParserRuleReturnScope<object, IToken> oslc_select()
	{
		EnterRule_oslc_select();
		EnterRule("oslc_select", 1);
		TraceIn("oslc_select", 1);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> properties1 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "oslc_select");
		DebugLocation(44, 1);
		try
		{
			// ../Grammars/OslcSelect.g:44:13: ( properties )
			DebugEnterAlt(1);
			// ../Grammars/OslcSelect.g:44:15: properties
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(44, 15);
			PushFollow(Follow._properties_in_oslc_select78);
			properties1=properties();
			PopFollow();

			adaptor.AddChild(root_0, properties1.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("oslc_select", 1);
			LeaveRule("oslc_select", 1);
			LeaveRule_oslc_select();
		}
		DebugLocation(45, 1);
		} finally { DebugExitRule(GrammarFileName, "oslc_select"); }
		return retval;

	}
	// $ANTLR end "oslc_select"

	partial void EnterRule_properties();
	partial void LeaveRule_properties();
	// $ANTLR start "properties"
	// ../Grammars/OslcSelect.g:47:1: properties : property ( ',' property )* -> ^( 'properties' property ( property )* ) ;
	[GrammarRule("properties")]
	private AstParserRuleReturnScope<object, IToken> properties()
	{
		EnterRule_properties();
		EnterRule("properties", 2);
		TraceIn("properties", 2);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal3 = default(IToken);
		AstParserRuleReturnScope<object, IToken> property2 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> property4 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal3_tree = default(object);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_property=new RewriteRuleSubtreeStream(adaptor,"rule property");
		try { DebugEnterRule(GrammarFileName, "properties");
		DebugLocation(47, 1);
		try
		{
			// ../Grammars/OslcSelect.g:47:12: ( property ( ',' property )* -> ^( 'properties' property ( property )* ) )
			DebugEnterAlt(1);
			// ../Grammars/OslcSelect.g:47:14: property ( ',' property )*
			{
			DebugLocation(47, 14);
			PushFollow(Follow._property_in_properties88);
			property2=property();
			PopFollow();

			stream_property.Add(property2.Tree);
			DebugLocation(47, 24);
			// ../Grammars/OslcSelect.g:47:24: ( ',' property )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_1 = input.LA(1);

				if ((LA1_1==COMMA))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// ../Grammars/OslcSelect.g:47:26: ',' property
					{
					DebugLocation(47, 26);
					char_literal3=(IToken)Match(input,COMMA,Follow._COMMA_in_properties93);  
					stream_COMMA.Add(char_literal3);

					DebugLocation(47, 30);
					PushFollow(Follow._property_in_properties95);
					property4=property();
					PopFollow();

					stream_property.Add(property4.Tree);

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }



			{
			// AST REWRITE
			// elements: PROPERTIES, property, property
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 47:43: -> ^( 'properties' property ( property )* )
			{
				DebugLocation(47, 46);
				// ../Grammars/OslcSelect.g:47:46: ^( 'properties' property ( property )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(47, 49);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(PROPERTIES, "PROPERTIES"), root_1);

				DebugLocation(47, 62);
				adaptor.AddChild(root_1, stream_property.NextTree());
				DebugLocation(47, 71);
				// ../Grammars/OslcSelect.g:47:71: ( property )*
				while ( stream_property.HasNext )
				{
					DebugLocation(47, 72);
					adaptor.AddChild(root_1, stream_property.NextTree());

				}
				stream_property.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("properties", 2);
			LeaveRule("properties", 2);
			LeaveRule_properties();
		}
		DebugLocation(48, 1);
		} finally { DebugExitRule(GrammarFileName, "properties"); }
		return retval;

	}
	// $ANTLR end "properties"

	partial void EnterRule_property();
	partial void LeaveRule_property();
	// $ANTLR start "property"
	// ../Grammars/OslcSelect.g:50:1: property : ( identifier | nested_property );
	[GrammarRule("property")]
	private AstParserRuleReturnScope<object, IToken> property()
	{
		EnterRule_property();
		EnterRule("property", 3);
		TraceIn("property", 3);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> identifier5 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> nested_property6 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "property");
		DebugLocation(50, 4);
		try
		{
			// ../Grammars/OslcSelect.g:50:13: ( identifier | nested_property )
			int alt2=2;
			try { DebugEnterDecision(2, false);
			int LA2_1 = input.LA(1);

			if (((LA2_1>=PNAME_LN && LA2_1<=PNAME_NS)))
			{
				int LA2_2 = input.LA(2);

				if ((LA2_2==EOF||(LA2_2>=CLOSE_CURLY_BRACE && LA2_2<=COMMA)))
				{
					alt2 = 1;
				}
				else if ((LA2_2==OPEN_CURLY_BRACE))
				{
					alt2 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 2, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA2_1==ASTERISK))
			{
				int LA2_2 = input.LA(2);

				if ((LA2_2==EOF||(LA2_2>=CLOSE_CURLY_BRACE && LA2_2<=COMMA)))
				{
					alt2 = 1;
				}
				else if ((LA2_2==OPEN_CURLY_BRACE))
				{
					alt2 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 2, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 2, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// ../Grammars/OslcSelect.g:50:15: identifier
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(50, 15);
				PushFollow(Follow._identifier_in_property128);
				identifier5=identifier();
				PopFollow();

				adaptor.AddChild(root_0, identifier5.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ../Grammars/OslcSelect.g:50:28: nested_property
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(50, 28);
				PushFollow(Follow._nested_property_in_property132);
				nested_property6=nested_property();
				PopFollow();

				adaptor.AddChild(root_0, nested_property6.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("property", 3);
			LeaveRule("property", 3);
			LeaveRule_property();
		}
		DebugLocation(51, 4);
		} finally { DebugExitRule(GrammarFileName, "property"); }
		return retval;

	}
	// $ANTLR end "property"

	partial void EnterRule_nested_property();
	partial void LeaveRule_nested_property();
	// $ANTLR start "nested_property"
	// ../Grammars/OslcSelect.g:53:1: nested_property : identifier OPEN_CURLY_BRACE properties CLOSE_CURLY_BRACE -> ^( 'nested_property' identifier properties ) ;
	[GrammarRule("nested_property")]
	private AstParserRuleReturnScope<object, IToken> nested_property()
	{
		EnterRule_nested_property();
		EnterRule("nested_property", 4);
		TraceIn("nested_property", 4);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken OPEN_CURLY_BRACE8 = default(IToken);
		IToken CLOSE_CURLY_BRACE10 = default(IToken);
		AstParserRuleReturnScope<object, IToken> identifier7 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> properties9 = default(AstParserRuleReturnScope<object, IToken>);

		object OPEN_CURLY_BRACE8_tree = default(object);
		object CLOSE_CURLY_BRACE10_tree = default(object);
		RewriteRuleITokenStream stream_CLOSE_CURLY_BRACE=new RewriteRuleITokenStream(adaptor,"token CLOSE_CURLY_BRACE");
		RewriteRuleITokenStream stream_OPEN_CURLY_BRACE=new RewriteRuleITokenStream(adaptor,"token OPEN_CURLY_BRACE");
		RewriteRuleSubtreeStream stream_properties=new RewriteRuleSubtreeStream(adaptor,"rule properties");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		try { DebugEnterRule(GrammarFileName, "nested_property");
		DebugLocation(53, 1);
		try
		{
			// ../Grammars/OslcSelect.g:53:17: ( identifier OPEN_CURLY_BRACE properties CLOSE_CURLY_BRACE -> ^( 'nested_property' identifier properties ) )
			DebugEnterAlt(1);
			// ../Grammars/OslcSelect.g:53:19: identifier OPEN_CURLY_BRACE properties CLOSE_CURLY_BRACE
			{
			DebugLocation(53, 19);
			PushFollow(Follow._identifier_in_nested_property145);
			identifier7=identifier();
			PopFollow();

			stream_identifier.Add(identifier7.Tree);
			DebugLocation(53, 30);
			OPEN_CURLY_BRACE8=(IToken)Match(input,OPEN_CURLY_BRACE,Follow._OPEN_CURLY_BRACE_in_nested_property147);  
			stream_OPEN_CURLY_BRACE.Add(OPEN_CURLY_BRACE8);

			DebugLocation(53, 47);
			PushFollow(Follow._properties_in_nested_property149);
			properties9=properties();
			PopFollow();

			stream_properties.Add(properties9.Tree);
			DebugLocation(53, 58);
			CLOSE_CURLY_BRACE10=(IToken)Match(input,CLOSE_CURLY_BRACE,Follow._CLOSE_CURLY_BRACE_in_nested_property151);  
			stream_CLOSE_CURLY_BRACE.Add(CLOSE_CURLY_BRACE10);



			{
			// AST REWRITE
			// elements: properties, NESTED_PROPERTIES, identifier
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 53:76: -> ^( 'nested_property' identifier properties )
			{
				DebugLocation(53, 79);
				// ../Grammars/OslcSelect.g:53:79: ^( 'nested_property' identifier properties )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(53, 82);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(NESTED_PROPERTIES, "NESTED_PROPERTIES"), root_1);

				DebugLocation(53, 100);
				adaptor.AddChild(root_1, stream_identifier.NextTree());
				DebugLocation(53, 111);
				adaptor.AddChild(root_1, stream_properties.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("nested_property", 4);
			LeaveRule("nested_property", 4);
			LeaveRule_nested_property();
		}
		DebugLocation(54, 1);
		} finally { DebugExitRule(GrammarFileName, "nested_property"); }
		return retval;

	}
	// $ANTLR end "nested_property"

	partial void EnterRule_identifier();
	partial void LeaveRule_identifier();
	// $ANTLR start "identifier"
	// ../Grammars/OslcSelect.g:56:1: identifier : ( prefixedName -> ^( 'prefixed_name' prefixedName ) | ASTERISK -> ^( 'wildcard' ) );
	[GrammarRule("identifier")]
	private AstParserRuleReturnScope<object, IToken> identifier()
	{
		EnterRule_identifier();
		EnterRule("identifier", 5);
		TraceIn("identifier", 5);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ASTERISK12 = default(IToken);
		AstParserRuleReturnScope<object, IToken> prefixedName11 = default(AstParserRuleReturnScope<object, IToken>);

		object ASTERISK12_tree = default(object);
		RewriteRuleITokenStream stream_ASTERISK=new RewriteRuleITokenStream(adaptor,"token ASTERISK");
		RewriteRuleSubtreeStream stream_prefixedName=new RewriteRuleSubtreeStream(adaptor,"rule prefixedName");
		try { DebugEnterRule(GrammarFileName, "identifier");
		DebugLocation(56, 1);
		try
		{
			// ../Grammars/OslcSelect.g:56:12: ( prefixedName -> ^( 'prefixed_name' prefixedName ) | ASTERISK -> ^( 'wildcard' ) )
			int alt3=2;
			try { DebugEnterDecision(3, false);
			int LA3_1 = input.LA(1);

			if (((LA3_1>=PNAME_LN && LA3_1<=PNAME_NS)))
			{
				alt3 = 1;
			}
			else if ((LA3_1==ASTERISK))
			{
				alt3 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 3, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// ../Grammars/OslcSelect.g:56:14: prefixedName
				{
				DebugLocation(56, 14);
				PushFollow(Follow._prefixedName_in_identifier173);
				prefixedName11=prefixedName();
				PopFollow();

				stream_prefixedName.Add(prefixedName11.Tree);


				{
				// AST REWRITE
				// elements: prefixedName, PREFIXED_NAME
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 56:27: -> ^( 'prefixed_name' prefixedName )
				{
					DebugLocation(56, 30);
					// ../Grammars/OslcSelect.g:56:30: ^( 'prefixed_name' prefixedName )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(56, 33);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(PREFIXED_NAME, "PREFIXED_NAME"), root_1);

					DebugLocation(56, 49);
					adaptor.AddChild(root_1, stream_prefixedName.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ../Grammars/OslcSelect.g:57:7: ASTERISK
				{
				DebugLocation(57, 7);
				ASTERISK12=(IToken)Match(input,ASTERISK,Follow._ASTERISK_in_identifier191);  
				stream_ASTERISK.Add(ASTERISK12);



				{
				// AST REWRITE
				// elements: WILDCARD
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 57:16: -> ^( 'wildcard' )
				{
					DebugLocation(57, 19);
					// ../Grammars/OslcSelect.g:57:19: ^( 'wildcard' )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(57, 22);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(WILDCARD, "WILDCARD"), root_1);

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("identifier", 5);
			LeaveRule("identifier", 5);
			LeaveRule_identifier();
		}
		DebugLocation(58, 1);
		} finally { DebugExitRule(GrammarFileName, "identifier"); }
		return retval;

	}
	// $ANTLR end "identifier"

	partial void EnterRule_prefixedName();
	partial void LeaveRule_prefixedName();
	// $ANTLR start "prefixedName"
	// ../Grammars/OslcSelect.g:60:1: prefixedName : ( PNAME_LN | PNAME_NS );
	[GrammarRule("prefixedName")]
	private AstParserRuleReturnScope<object, IToken> prefixedName()
	{
		EnterRule_prefixedName();
		EnterRule("prefixedName", 6);
		TraceIn("prefixedName", 6);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set13 = default(IToken);

		object set13_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "prefixedName");
		DebugLocation(60, 4);
		try
		{
			// ../Grammars/OslcSelect.g:61:5: ( PNAME_LN | PNAME_NS )
			DebugEnterAlt(1);
			// ../Grammars/OslcSelect.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(61, 5);

			set13=(IToken)input.LT(1);
			if ((input.LA(1)>=PNAME_LN && input.LA(1)<=PNAME_NS))
			{
				input.Consume();
				adaptor.AddChild(root_0, (object)adaptor.Create(set13));
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("prefixedName", 6);
			LeaveRule("prefixedName", 6);
			LeaveRule_prefixedName();
		}
		DebugLocation(63, 4);
		} finally { DebugExitRule(GrammarFileName, "prefixedName"); }
		return retval;

	}
	// $ANTLR end "prefixedName"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _properties_in_oslc_select78 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _property_in_properties88 = new BitSet(new ulong[]{0x42UL});
		public static readonly BitSet _COMMA_in_properties93 = new BitSet(new ulong[]{0x30010UL});
		public static readonly BitSet _property_in_properties95 = new BitSet(new ulong[]{0x42UL});
		public static readonly BitSet _identifier_in_property128 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _nested_property_in_property132 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _identifier_in_nested_property145 = new BitSet(new ulong[]{0x4000UL});
		public static readonly BitSet _OPEN_CURLY_BRACE_in_nested_property147 = new BitSet(new ulong[]{0x30010UL});
		public static readonly BitSet _properties_in_nested_property149 = new BitSet(new ulong[]{0x20UL});
		public static readonly BitSet _CLOSE_CURLY_BRACE_in_nested_property151 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _prefixedName_in_identifier173 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ASTERISK_in_identifier191 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace  OSLC4Net.Core.Query.Impl 
